from imports import *

load_dotenv()
BOT_TOKEN = os.environ.get('BOT_TOKEN')

bot = Bot(token=BOT_TOKEN)
storage = MemoryStorage()
dp = Dispatcher(bot, storage=storage)

class RecipeStates(StatesGroup):
    waiting_for_recipe_name = State()

'''     —Å—Ç–∞—Ä—Ç      '''
@dp.message_handler(commands=['start'])
async def start_command(message: types.Message):
    await send_message(message.chat.id, WELCOME_MESSAGE, reply_markup=keyboard_inline)

@dp.message_handler(lambda message: message.text == "–≤ –º–µ–Ω—é")
async def menu_button_click(message: types.Message):
    await send_message_with_menu(message.chat.id, WELCOME_MESSAGE)

'''     menu      '''
@dp.message_handler(commands=['menu'])
async def menu_command(message: types.Message):
    await send_message_with_menu(message.chat.id, WELCOME_MESSAGE)

'''     kushat      '''

@dp.message_handler(commands=['kushat'])
async def kushat_command(message: types.Message):
    await message.answer("–í–≤–µ–¥–∏—Ç–µ –±–ª—é–¥–æ:")
    await RecipeStates.waiting_for_recipe_name.set()

@dp.callback_query_handler(lambda c: c.data == "kushat")
async def handle_kushat_callback(call: types.CallbackQuery):
    await kushat_command(call.message)

async def send_message(chat_id: int, text: str, reply_markup=None):
    await bot.send_message(chat_id, text, reply_markup=reply_markup)

async def send_message_with_menu(chat_id: int, text: str):
    keyboard = InlineKeyboardMarkup().add(InlineKeyboardButton(text="—è —Ö–æ—á—É —Å—Ç–∞—Ç—å –∂–µ–Ω—â–∏–Ω–æ–π...", callback_data="first_button"))
    await send_message(chat_id, text, reply_markup=keyboard)

keyboard_inline = InlineKeyboardMarkup().add(InlineKeyboardButton(text="—è —Ö–æ—á—É —Å—Ç–∞—Ç—å –∂–µ–Ω—â–∏–Ω–æ–π...", callback_data="first_button"))
button_menu = KeyboardButton("–≤ –º–µ–Ω—é")
keyboard_reply = ReplyKeyboardMarkup(resize_keyboard=True).add(button_menu)


@dp.callback_query_handler(text=["first_button"])
async def check_button(call: types.CallbackQuery):
    await call.message.answer("–í–≤–µ–¥–∏—Ç–µ –±–ª—é–¥–æ:")
    await RecipeStates.waiting_for_recipe_name.set()
    await call.answer()




@dp.callback_query_handler(lambda c: c.data == "menu", state='*')
async def handle_menu_callback(call: types.CallbackQuery, state: FSMContext):
    # –ü—Ä–æ–≥—Ä–∞–º–º–Ω–æ –≤—ã–∑—ã–≤–∞–µ–º –æ–±—Ä–∞–±–æ—Ç—á–∏–∫ –∫–æ–º–∞–Ω–¥—ã /menu
    await state.finish()
    await menu_command(call.message)
    await call.answer()

@dp.callback_query_handler(text="button_one")
async def button_one_handler(call: types.CallbackQuery):
    await call.message.answer("–í–≤–µ–¥–∏—Ç–µ –±–ª—é–¥–æ:")
    await RecipeStates.waiting_for_recipe_name.set()
    await call.answer()


# –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –º–æ—Ä—Ñ–æ–ª–æ–≥–∏—á–µ—Å–∫–æ–≥–æ –∞–Ω–∞–ª–∏–∑–∞—Ç–æ—Ä–∞
morph = pymorphy2.MorphAnalyzer()

# –°—Ç–æ–ø-—Å–ª–æ–≤–∞
STOPWORDS = {"–∏", "—Å", "–≤", "–Ω–∞", "–¥–ª—è", "–ø–æ", "–∏–∑", "–∞", "–∏–ª–∏", "–æ—Ç", "–±–µ–∑"}

def lemmatize_word(word):
    """–ü—Ä–∏–≤–µ–¥–µ–Ω–∏–µ —Å–ª–æ–≤–∞ –∫ –Ω–æ—Ä–º–∞–ª—å–Ω–æ–π —Ñ–æ—Ä–º–µ (–ª–µ–º–º–∞—Ç–∏–∑–∞—Ü–∏—è)"""
    return morph.parse(word)[0].normal_form

def lemmatize_text(text):
    """–õ–µ–º–º–∞—Ç–∏–∑–∞—Ü–∏—è —Ç–µ–∫—Å—Ç–∞: —É–¥–∞–ª—è–µ—Ç —Å—Ç–æ–ø-—Å–ª–æ–≤–∞ –∏ –ø—Ä–∏–≤–æ–¥–∏—Ç –∫ –ª–µ–º–º–∞–º"""
    words = re.split(r"[^\w]+", text.lower())  # –†–∞–∑–±–∏–≤–∞–µ–º –Ω–∞ —Å–ª–æ–≤–∞
    return [lemmatize_word(word) for word in words if word and word not in STOPWORDS]

# –∑–∞–ø—Ä–æ—Å –∫ —Å–∞–π—Ç—É —Å —Ä–µ—Ü–µ–ø—Ç–∞–º–∏
def fetch_reviews(dish):
    url = f"https://www.gastronom.ru/search?search={quote(dish)}&pageType=recipepage"
    print(url)

    try:
        # –°–æ–∑–¥–∞–µ–º SSL –∫–æ–Ω—Ç–µ–∫—Å—Ç
        context = ssl.create_default_context(cafile=certifi.where())
        cj = CookieJar()
        opener = urllib.request.build_opener(
            urllib.request.HTTPCookieProcessor(cj),
            urllib.request.HTTPSHandler(context=context)  # –î–æ–±–∞–≤–ª—è–µ–º –æ–±—Ä–∞–±–æ—Ç—á–∏–∫ HTTPS —Å –∫–æ–Ω—Ç–µ–∫—Å—Ç–æ–º
        )

        req = urllib.request.Request(url, None)
        response = opener.open(req)

        raw_response = response.read().decode('utf-8', errors='ignore')
        response.close()

        soup = BeautifulSoup(raw_response, 'html.parser')

        # –õ–µ–º–º–∞—Ç–∏–∑–∏—Ä—É–µ–º –∑–∞–ø—Ä–æ—Å –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
        user_keywords = set(lemmatize_text(dish))

        recipes_links = []
        recipe_titles = []
        recipe_image_urls = []

        all_links = soup.find_all('a', class_="_link_iku8o_14", itemprop="url")
        for link in all_links:
            href = link.get('href')
            if href and "recipe" in href:
                parent_div = link.find_next('a', class_="_name_iku8o_19")
                if parent_div:
                    title_tag = parent_div.find('span', itemprop="name")
                    if title_tag:
                        recipe_title = title_tag.get_text(strip=True).lower()

                        # –õ–µ–º–º–∞—Ç–∏–∑–∏—Ä—É–µ–º –∑–∞–≥–æ–ª–æ–≤–æ–∫ —Ä–µ—Ü–µ–ø—Ç–∞
                        title_keywords = set(lemmatize_text(recipe_title))

                        # –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ –≤—Å–µ –∫–ª—é—á–µ–≤—ã–µ —Å–ª–æ–≤–∞ –∑–∞–ø—Ä–æ—Å–∞ –µ—Å—Ç—å –≤ –∑–∞–≥–æ–ª–æ–≤–∫–µ
                        if user_keywords.issubset(title_keywords):
                            recipes_links.append(f"https://www.gastronom.ru{href}")
                            recipe_titles.append(recipe_title)

                            image_tag = link.find('img', itemprop="image")
                            recipe_image_urls.append(
                                image_tag.get('src') if image_tag else None
                            )

        print("–ù–∞–π–¥–µ–Ω–Ω—ã–µ —Å—Å—ã–ª–∫–∏:", recipes_links)
        print("–ù–∞–∑–≤–∞–Ω–∏—è –±–ª—é–¥:", recipe_titles)
        print("URL –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–π:", recipe_image_urls)

        return recipes_links, recipe_titles, recipe_image_urls

    except urllib.request.HTTPError as inst:
        output = format(inst)
        print(output)
        return [], [], []


# –î–æ—Å—Ç–∞–µ–º –∏–Ω–≥—Ä–∏–¥–∏–µ–Ω—Ç—ã –∏–∑ —Ä–µ—Ü–µ–ø—Ç–∞
def fetch_ingredients_from_recipe(recipes_links):
    if not recipes_links:
        return [], None  # –í–æ–∑–≤—Ä–∞—â–∞–µ–º —Å–ø–∏—Å–æ–∫ –∏–Ω–≥—Ä–µ–¥–∏–µ–Ω—Ç–æ–≤ –∏ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –ø–æ—Ä—Ü–∏–π

    first_link = recipes_links[0]
    response = requests.get(first_link)
    soup = BeautifulSoup(response.text, 'html.parser')

    # –ò—â–µ–º –±–ª–æ–∫ —Å –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ–º –ø–æ—Ä—Ü–∏–π
    portions_div = soup.find('div', class_="_text_1prcq_11", itemprop="recipeYield")
    portions = None
    if portions_div:
        portions_text = portions_div.get_text(strip=True)
        if "–ü–æ—Ä—Ü–∏–π:" in portions_text:
            portions = portions_text.split("–ü–æ—Ä—Ü–∏–π:")[-1].strip()

    # –ò—â–µ–º –∏–Ω–≥—Ä–µ–¥–∏–µ–Ω—Ç—ã
    ingredients_div = soup.find('div', class_="_ingredients_1r0sn_28")
    if not ingredients_div:
        return [], portions

    ingredients = []
    ingredient_tags = ingredients_div.find_all('div', itemprop="recipeIngredient")
    for tag in ingredient_tags:
        ingredient = tag.get_text(strip=True)
        ingredients.append(ingredient)

    print("–ò–Ω–≥—Ä–µ–¥–∏–µ–Ω—Ç—ã:", ingredients)
    print("–ö–æ–ª–∏—á–µ—Å—Ç–≤–æ –ø–æ—Ä—Ü–∏–π:", portions)
    return ingredients, portions


# –ò—â–µ–º —Å—Å—ã–ª–∫–∏ –Ω–∞ –ø—Ä–æ–¥—É–∫—Ç—ã –¥–ª—è —Ä–µ—Ü–µ–ø—Ç–∞ –≤ –∏–Ω—Ç–µ—Ä–Ω–µ—Ç–µ
def search_ingredient_online(ingredient):
    search_query = f"–∫—É–ø–∏—Ç—å {ingredient} –≤ –º–æ—Å–∫–≤–µ"
    search_url = f"https://www.google.com/search?q={search_query}&tbm=shop"

    response = requests.get(search_url, headers={"User-Agent": "Mozilla/5.0"})
    if response.status_code != 200:
        return None

    soup = BeautifulSoup(response.text, 'html.parser')

    links = []
    for item in soup.find_all('a', href=True):
        href = item['href']
        if "url?q=" in href and not "webcache" in href:
            parsed_url = parse_qs(urlparse(href).query).get('q', [None])[0]
            if parsed_url:
                links.append(parsed_url)

    return links[0] if links else None


@dp.message_handler(state=RecipeStates.waiting_for_recipe_name, content_types=types.ContentType.TEXT)
async def recipe_name_handler(message: types.Message, state: FSMContext):
    if message.text == "–≤ –º–µ–Ω—é" or message.text == '/menu':
        await send_message_with_menu(message.chat.id, WELCOME_MESSAGE)
        await state.finish()  # –ó–∞–≤–µ—Ä—à–∞–µ–º —Ç–µ–∫—É—â–µ–µ —Å–æ—Å—Ç–æ—è–Ω–∏–µ
        return

    recipe_name = message.text

    await message.answer("–ò—â—É —Ä–µ—Ü–µ–ø—Ç—ã –∏ –∏–Ω–≥—Ä–µ–¥–∏–µ–Ω—Ç—ã, —ç—Ç–æ –º–æ–∂–µ—Ç –∑–∞–Ω—è—Ç—å –Ω–µ–º–Ω–æ–≥–æ –≤—Ä–µ–º–µ–Ω–∏...ü´¶")
    recipe_links, recipe_titles, recipe_image_urls = fetch_reviews(recipe_name)

    if not recipe_links:
        await message.answer("–†–µ—Ü–µ–ø—Ç—ã –Ω–µ –Ω–∞–π–¥–µ–Ω—ã.")
        await state.finish()
        return

    await state.update_data(recipe_links=recipe_links, recipe_titles=recipe_titles, recipe_image_urls=recipe_image_urls)

    await show_recipe(message, state, recipe_index=0)

# –ø–æ–∫–∞–∑—ã–≤–∞–µ–º –ø–µ—Ä–≤—ã–µ <=3 –Ω–∞–π–¥–µ–Ω–Ω—ã—Ö –±–ª—é–¥–∞
async def show_recipe(message: types.Message, state: FSMContext, recipe_index: int):
    data = await state.get_data()
    recipe_links = data['recipe_links']
    recipe_titles = data['recipe_titles']
    recipe_image_urls = data['recipe_image_urls']

    if recipe_index >= len(recipe_links):
        await message.answer("–ë–æ–ª—å—à–µ —Ä–µ—Ü–µ–ø—Ç–æ–≤ –Ω–µ—Ç.")
        await state.finish()
        return

    # –ü–æ–ª—É—á–∞–µ–º –¥–æ 3 –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–π –¥–ª—è –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏—è
    images_to_send = recipe_image_urls[recipe_index:recipe_index + 3]
    keyboard = InlineKeyboardMarkup(row_width=3)

    for i, image_url in enumerate(images_to_send):
        if image_url:
            # –ü–æ–ª—É—á–∞–µ–º –Ω–∞–∑–≤–∞–Ω–∏–µ —Ä–µ—Ü–µ–ø—Ç–∞ –¥–ª—è —Ç–µ–∫—É—â–µ–≥–æ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è
            recipe_title = recipe_titles[recipe_index + i] if recipe_index + i < len(recipe_titles) else "–ë–µ–∑ –Ω–∞–∑–≤–∞–Ω–∏—è"
            button = InlineKeyboardButton(
                text=f"–†–µ—Ü–µ–ø—Ç {i + 1}",
                callback_data=f"select_image_{recipe_index + i}"  # –£–Ω–∏–∫–∞–ª—å–Ω—ã–π –∏–Ω–¥–µ–∫—Å —Ä–µ—Ü–µ–ø—Ç–∞
            )
            keyboard.add(button)
            # –û—Ç–ø—Ä–∞–≤–ª—è–µ–º –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ —Å –ø–æ–¥–ø–∏—Å—å—é
            await bot.send_photo(message.chat.id, image_url, caption=recipe_title)

    # –î–æ–±–∞–≤–ª—è–µ–º –∫–Ω–æ–ø–∫–∏ "–°–ª–µ–¥—É—é—â–∏–µ –≤–∞—Ä–∏–∞–Ω—Ç—ã" –∏ "–í –º–µ–Ω—é"
    keyboard.add(
        InlineKeyboardButton(
            text="–°–ª–µ–¥—É—é—â–∏–µ –≤–∞—Ä–∏–∞–Ω—Ç—ã",
            callback_data="next_recipe_set"
        )
    )

    keyboard.add(
        InlineKeyboardButton(
            text="–í –º–µ–Ω—é",
            callback_data="menu"
        )
    )
    await message.answer("–í—ã–±–µ—Ä–∏—Ç–µ —Ä–µ—Ü–µ–ø—Ç:", reply_markup=keyboard)


# –ø–æ–∫–∞–∑—ã–≤–∞–µ–º –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é —Ä–µ—Ü–µ–ø—Ç —Å –ø—Ä–æ–¥—É–∫—Ç–∞–º–∏
@dp.callback_query_handler(lambda c: c.data.startswith("select_image_"),
                           state=RecipeStates.waiting_for_recipe_name)
async def show_recipe_to_user(call: types.CallbackQuery, state: FSMContext):
    parts = call.data.split("_")
    if len(parts) != 3:
        await call.answer("–û—à–∏–±–∫–∞ –≤—ã–±–æ—Ä–∞ —Ä–µ—Ü–µ–ø—Ç–∞.")
        return

    try:
        recipe_index = int(parts[2])
    except ValueError:
        await call.answer("–ù–µ–∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã–π –∏–Ω–¥–µ–∫—Å —Ä–µ—Ü–µ–ø—Ç–∞.")
        return

    data = await state.get_data()
    recipe_links = data.get('recipe_links', [])
    recipe_titles = data.get('recipe_titles', [])

    if recipe_index < 0 or recipe_index >= len(recipe_links):
        await call.answer("–ù–µ–∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã–π –∏–Ω–¥–µ–∫—Å —Ä–µ—Ü–µ–ø—Ç–∞.")
        return

    selected_recipe_link = recipe_links[recipe_index]
    selected_recipe_title = recipe_titles[recipe_index]

    # –ò–∑–≤–ª–µ–∫–∞–µ–º –∏–Ω–≥—Ä–µ–¥–∏–µ–Ω—Ç—ã –∏ –∫–æ–ª-–≤–æ –ø–æ—Ä—Ü–∏–π
    ingredients, portions = fetch_ingredients_from_recipe([selected_recipe_link])

    if not ingredients:
        await call.message.answer("–ò–Ω–≥—Ä–µ–¥–∏–µ–Ω—Ç—ã –Ω–µ –Ω–∞–π–¥–µ–Ω—ã.")
        await state.finish()
        return

    # –û—Ç–ø—Ä–∞–≤–ª—è–µ–º –Ω–∞–∑–≤–∞–Ω–∏–µ —Ä–µ—Ü–µ–ø—Ç–∞
    await bot.send_message(
        call.message.chat.id,
        selected_recipe_title,
        reply_to_message_id=call.message.message_id
    )

    # –û—Ç–ø—Ä–∞–≤–ª—è–µ–º —Å—Å—ã–ª–∫—É –Ω–∞ —Ä–µ—Ü–µ–ø—Ç
    await call.message.answer(
        f"–°—Å—ã–ª–∫–∞ –Ω–∞ —Ä–µ—Ü–µ–ø—Ç: [—Ç—ã–∫]({selected_recipe_link})",
        parse_mode="Markdown",
        disable_web_page_preview=True,
    )

    # –û—Ç–ø—Ä–∞–≤–ª—è–µ–º –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –ø–æ—Ä—Ü–∏–π
    await call.message.answer(f"–ö–æ–ª-–≤–æ –ø–æ—Ä—Ü–∏–π –≤ —Ä–µ—Ü–µ–ø—Ç–µ: {portions}")

    # –ì–æ—Ç–æ–≤–∏–º —Å–æ–æ–±—â–µ–Ω–∏–µ —Å–æ —Å–ø–∏—Å–∫–æ–º –∏–Ω–≥—Ä–µ–¥–∏–µ–Ω—Ç–æ–≤
    result_message = "üç¥ **–ò–Ω–≥—Ä–µ–¥–∏–µ–Ω—Ç—ã –¥–ª—è —Ä–µ—Ü–µ–ø—Ç–∞** üç¥\n\n"

    for idx, ingredient in enumerate(ingredients, start=1):

        # –î–∞–ª–µ–µ –º—ã –ø—Ä–∏–≤–æ–¥–∏–º –∑–∞–ø—Ä–æ—Å –∫ –≤–∏–¥—É "–∏–Ω–≥—Ä–∏–¥–∏–µ–Ω—Ç - –≥—Ä–∞–º–º–æ–≤–∫–∞", –µ—Å–ª–∏ —ç—Ç–æ –≤–æ–∑–º–æ–∂–Ω–æ
        if "-" in ingredient or "‚Äì" in ingredient:
            formatted_ingredient = ingredient.strip()
            if formatted_ingredient:
                formatted_ingredient = formatted_ingredient[0].upper() + formatted_ingredient[1:]
        else:
            match = re.search(
                r'^(.*?)(\d+(?:\.\d+)?\s*(?:–≥|–∫–≥|–º–ª|—Å—Ç\.–ª\.?|—á\.–ª\.?|—à—Ç\.?|–∑—É–±—á–∏–∫\(–∞\)|–≤–µ—Ç–æ—á–∫–∞\(–∏\)|–ø–∞–∫–µ—Ç–∏–∫\(–∏\)|—Å—Ç–∞–∫–∞–Ω–∞?))$',
                ingredient.strip(),
                re.IGNORECASE
            )
            if match:
                name = match.group(1).strip()
                quantity = match.group(2).strip()

                if name:
                    name = name[0].upper() + name[1:]

                formatted_ingredient = f"{name} - {quantity}"
            else:
                formatted_ingredient = ingredient.strip()
                if formatted_ingredient:
                    formatted_ingredient = (
                        formatted_ingredient[0].upper() + formatted_ingredient[1:]
                    )

        # –°—Å—ã–ª–∫–∞ "–∫—É–ø–∏—Ç—å"
        purchase_link = search_ingredient_online(formatted_ingredient)
        if purchase_link:
            result_message += f"{idx}. **{formatted_ingredient}** üõí [–ö—É–ø–∏—Ç—å]({purchase_link})\n"
        else:
            result_message += f"{idx}. **{formatted_ingredient}** ‚ùå _–°—Å—ã–ª–∫–∞ –æ—Ç—Å—É—Ç—Å—Ç–≤—É–µ—Ç_\n"

    # –û—Ç–ø—Ä–∞–≤–ª—è–µ–º –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é —Å–ø–∏—Å–æ–∫ –∏–Ω–≥—Ä–µ–¥–∏–µ–Ω—Ç–æ–≤
    await call.message.answer(
        result_message,
        parse_mode="Markdown",
        disable_web_page_preview=True,
    )

    # –°–ø—Ä–∞—à–∏–≤–∞–µ–º, —É—Å—Ç—Ä–∞–∏–≤–∞–µ—Ç –ª–∏ —Ä–µ—Ü–µ–ø—Ç
    try:
        await call.message.answer("–£—Å—Ç—Ä–∞–∏–≤–∞–µ—Ç –ª–∏ —Ä–µ—Ü–µ–ø—Ç?", reply_markup=next_recipe_keyboard)
    except InvalidQueryID:
        print("–ü–æ–ø—ã—Ç–∫–∞ –æ—Ç–≤–µ—Ç–∏—Ç—å –Ω–∞ —É—Å—Ç–∞—Ä–µ–≤—à–∏–π –∑–∞–ø—Ä–æ—Å.")

    await state.update_data(current_recipe_index=recipe_index)
    await call.answer()

# –û–±—Ä–∞–±–æ—Ç—á–∏–∫ –¥–ª—è –∫–Ω–æ–ø–∫–∏ "–°–ª–µ–¥—É—é—â–∏–µ –≤–∞—Ä–∏–∞–Ω—Ç—ã"
@dp.callback_query_handler(lambda call: call.data == "next_recipe_set", state=RecipeStates.waiting_for_recipe_name)
async def handle_next_recipe_set(call: types.CallbackQuery, state: FSMContext):
    # –ü–æ–ª—É—á–∞–µ–º —Ç–µ–∫—É—â–∏–π –∏–Ω–¥–µ–∫—Å —Ä–µ—Ü–µ–ø—Ç–∞ –∏–∑ —Å–æ—Å—Ç–æ—è–Ω–∏—è
    data = await state.get_data()
    current_recipe_index = data.get("current_recipe_index", 0)

    # –£–≤–µ–ª–∏—á–∏–≤–∞–µ–º –∏–Ω–¥–µ–∫—Å –¥–ª—è –ø–æ–∫–∞–∑–∞ —Å–ª–µ–¥—É—é—â–∏—Ö —Ä–µ—Ü–µ–ø—Ç–æ–≤
    new_recipe_index = current_recipe_index + 3
    await state.update_data(current_recipe_index=new_recipe_index)

    # –û—Ç–æ–±—Ä–∞–∂–∞–µ–º —Å–ª–µ–¥—É—é—â–∏–µ —Ä–µ—Ü–µ–ø—Ç—ã
    await show_recipe(call.message, state, recipe_index=new_recipe_index)

    # –ó–∞–∫—Ä—ã–≤–∞–µ–º –≤—Å–ø–ª—ã–≤–∞—é—â–µ–µ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ
    await call.answer()

next_recipe_keyboard = InlineKeyboardMarkup(row_width=2).add(
    InlineKeyboardButton("–î–∞", callback_data="recipe_accept"),
    InlineKeyboardButton("–ù–µ—Ç", callback_data="recipe_reject")
).row(
    InlineKeyboardButton("–í –º–µ–Ω—é", callback_data="menu")
)

# –æ–±—Ä–∞–±–æ—Ç—á–∏–∫ "–î–∞", –∫–æ–≥–¥–∞ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é –ø–æ–Ω—Ä–∞–≤–∏–ª—Å—è –ø—Ä–µ–¥–ª–æ–∂–µ–Ω–Ω—ã–π —Ä–µ—Ü–µ–ø—Ç
@dp.callback_query_handler(lambda c: c.data == "recipe_accept", state=RecipeStates.waiting_for_recipe_name)
async def handle_recipe_accept(call: types.CallbackQuery, state: FSMContext):

    keyboard = InlineKeyboardMarkup(row_width=3)

    keyboard.add(
        InlineKeyboardButton("–í—ã–±—Ä–∞—Ç—å –Ω–æ–≤–æ–µ –±–ª—é–¥–æ", callback_data="kushat"),
    )

    keyboard.add(
        InlineKeyboardButton("–í –º–µ–Ω—é", callback_data="menu")
    )

    await call.message.answer("–ü—Ä–∏—è—Ç–Ω–æ–≥–æ –∞–ø–ø–µ—Ç–∏—Ç–∞!", reply_markup=keyboard)
    await state.finish()
    await call.answer()

# –æ–±—Ä–∞–±–æ—Ç—á–∏–∫ "–ù–µ—Ç", –∫–æ–≥–¥–∞ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é –Ω–µ –ø–æ–Ω—Ä–∞–≤–∏–ª—Å—è –ø—Ä–µ–¥–ª–æ–∂–µ–Ω–Ω—ã–π —Ä–µ—Ü–µ–ø—Ç
@dp.callback_query_handler(lambda c: c.data == "recipe_reject", state=RecipeStates.waiting_for_recipe_name)
async def handle_recipe_reject(call: types.CallbackQuery, state: FSMContext):
    data = await state.get_data()
    current_recipe_index = data.get("current_recipe_index", 0)
    await show_recipe(call.message, state, recipe_index=current_recipe_index + 1)  # –ü–æ–∫–∞–∑–∞—Ç—å —Å–ª–µ–¥—É—é—â–∏–π —Ä–µ—Ü–µ–ø—Ç
    await call.answer()



@dp.callback_query_handler(lambda call: call.data == "next_recipe_set", state=RecipeStates.waiting_for_recipe_name)
async def handle_next_recipe_set(call: types.CallbackQuery, state: FSMContext):
    # –ü–æ–ª—É—á–∞–µ–º —Ç–µ–∫—É—â–∏–π –∏–Ω–¥–µ–∫—Å —Ä–µ—Ü–µ–ø—Ç–∞
    data = await state.get_data()
    current_recipe_index = data.get("current_recipe_index", 0)

    # –£–≤–µ–ª–∏—á–∏–≤–∞–µ–º –∏–Ω–¥–µ–∫—Å –¥–ª—è –ø–æ–∫–∞–∑–∞ —Å–ª–µ–¥—É—é—â–∏—Ö —Ä–µ—Ü–µ–ø—Ç–æ–≤
    new_recipe_index = current_recipe_index + 3
    await state.update_data(current_recipe_index=new_recipe_index)

    # –û—Ç–æ–±—Ä–∞–∂–∞–µ–º —Å–ª–µ–¥—É—é—â–∏–µ —Ä–µ—Ü–µ–ø—Ç—ã
    await show_recipe(call.message, state, recipe_index=new_recipe_index)

    await call.answer()

# –û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º –∑–∞–ø—Ä–æ—Å —Å–ª–µ–¥—É—é—â–µ–≥–æ —Ä–µ—Ü–µ–ø—Ç–∞
@dp.callback_query_handler(lambda c: c.data in ["show_next_recipe", "end_recipe_view"], state=RecipeStates.waiting_for_recipe_name)
async def handle_next_recipe(call: types.CallbackQuery, state: FSMContext):
    data = await state.get_data()
    current_recipe_index = data.get("current_recipe_index", 0)

    if call.data == "show_next_recipe":
        await show_recipe(call.message, state, recipe_index=current_recipe_index + 1)
    elif call.data == "end_recipe_view":
        keyboard = InlineKeyboardMarkup(row_width=3)

        keyboard.add(
            InlineKeyboardButton("–í—ã–±—Ä–∞—Ç—å –Ω–æ–≤–æ–µ –±–ª—é–¥–æ", callback_data="kushat"),
        )

        keyboard.add(
            InlineKeyboardButton("–í –º–µ–Ω—é", callback_data="menu")
        )
        await call.message.answer("–ü—Ä–∏—è—Ç–Ω–æ–≥–æ –∞–ø–ø–µ—Ç–∏—Ç–∞!", reply_markup=keyboard)
        await state.finish()

    await call.answer()
